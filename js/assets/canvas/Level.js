// -- user code here --
import Hud from '../../Hud';
import TileMap from '../../Map/TileMap';
import Player from '../sprites/player';
import Gem from '../sprites/gem';
import { IntroductionText } from '../../Text'

import tiles from '../tiles_x.png';
import gems from '../gems.png';
import Characters from '../characters';

/* --- start generated code --- */

// Generated by  1.4.4 (Phaser v2.6.2)


class Level extends Phaser.State {

	/**
	 * Level.
	 */
	constructor() {

		super();


		this.cursors = null;

	}

	init() {

		this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
		this.scale.pageAlignHorizontally = true;
		this.scale.pageAlignVertically = true;

	}

	preload() {

		this.preloadImages();

	}

	create() {
		this.customCreate();

	}

	/* state-methods-begin */
	render() {
		// this.game.debug.body(this.player);
	}

	update() {
		this.game.physics.arcade.collide(this.player, this.layer);
		this.Hud.update();
	}

	preloadImages() {
		this.game.load.image('tiles', tiles);
		this.game.load.spritesheet('gems', gems, 32, 32);
		this.game.load.spritesheet('help', 'js/assets/help.png', 40, 20)
		this.game.load.spritesheet('warrior_m', Characters.WarriorM, 32, 32, 12);
	}

	customCreate() {
		const mapData = new TileMap(64, 64, 10);
		this.cache.addTilemap('dynamicMap', null, mapData.getCSV(), Phaser.Tilemap.CSV);
		const map = this.add.tilemap('dynamicMap', 32, 32);
		map.addTilesetImage('tiles', 'tiles', 32, 32);
		this.layer = map.createLayer(0);
		this.layer.resizeWorld();
		map.setCollisionBetween(1, 1);

		// Add Gems
		mapData.gems.forEach((gem) => {
			const gemLoc = gem.location.getPixelLocation();
			const gemSprite = new Gem({ game: this.game, x: gemLoc.x, y: gemLoc.y, gemType: gem.gemType });
			this.game.add.existing(gemSprite);
		});

		// Add player
		const playerLoc = mapData.playerStartLocation.getPixelLocation();
		this.player = new Player({ game: this.game, x: playerLoc.x, y: playerLoc.y });
		this.game.camera.follow(this.player);
		this.game.add.existing(this.player);

		this.Hud = new Hud(this.game);
		for (let i = 0; i < IntroductionText.length; i += 1) {
			this.Hud.addMessageToQueue(IntroductionText[i]);
		}
	}
	/* state-methods-end */

}
/* --- end generated code --- */
export default Level
